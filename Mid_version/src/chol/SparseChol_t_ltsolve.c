/**
 * @file t_SparseChol_ltsolve.c
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2020-09-22
 * 
 * @copyright Copyright (c) 2020
 * 
 */
#undef FORM_NAME
#undef LSOLVE
#undef DIAG

/* -------------------------------------------------------------------------- */
/* 定义方法 */
/* -------------------------------------------------------------------------- */

#ifdef LL
/* LL': 求解非单位对角的Lx=b */
#define FORM_NAME(prefix,rank) prefix ## ll_ltsolve_ ## rank
#define DIAG

#elif defined (LD)
/* LDL':求解LDx=b */
#define FORM_NAME(prefix,rank) prefix ## ldl_dltsolve_ ## rank
#define DIAG

#else
/* LDL':求解单位对角的Lx=b */
#define FORM_NAME(prefix,rank) prefix ## ldl_ltsolve_ ## rank

#endif

/* LSOLVE(k)定义了一个n×k右手边（right-hand-side）的例程的名称。 */
#define LSOLVE(prefix,rank) FORM_NAME(prefix,rank)

#ifdef REAL

/* ========================================================================== */
/* === LSOLVE (1) =========================================================== */
/* ========================================================================== */

/* 求解L'x=b,其中b有一列  */

static void LSOLVE (PREFIX,1)
(
    sparse_factor *L,
    double X [ ]                        /* n-by-1按行排列 */
)
{
    double *Lx = L->x ;
    Int *Li = L->i ;
    Int *Lp = L->p ;
    Int *Lnz = L->nz ;
    Int j, n = L->n ;

    for (j = n-1 ; j >= 0 ; )
    {
	/* 得到列j的开头、结尾以及长度 */
	Int p = Lp [j] ;
	Int lnz = Lnz [j] ;
	Int pend = p + lnz ;

	/* 找到超节点链 (j, j-1, j-2) */
	if (j < 4 || lnz != Lnz [j-1] - 1 || Li [Lp [j-1]+1] != j)
	{

	    /* -------------------------------------------------------------- */
	    /* 用L的一列求解 */
	    /* -------------------------------------------------------------- */

	    double y = X [j] ;
#ifdef DIAG
	    double d = Lx [p] ;
#endif
#ifdef LD
	    y /= d ;
#endif
	    for (p++ ; p < pend ; p++)
	    {
		y -= Lx [p] * X [Li [p]] ;
	    }
#ifdef LL
	    X [j] = y / d ;
#else
	    X [j] = y ;
#endif
	    j-- ;	/* 前进到L的下一列 */

	}
	else if (lnz != Lnz [j-2]-2 || Li [Lp [j-2]+2] != j)
	{

	    /* -------------------------------------------------------------- */
	    /* 用L的两列求解超节点 */
	    /* -------------------------------------------------------------- */

	    double y [2], t ;
	    Int q = Lp [j-1] ;
#ifdef DIAG
	    double d [2] ;
	    d [0] = Lx [p] ;
	    d [1] = Lx [q] ;
#endif
	    t = Lx [q+1] ;
#ifdef LD
	    y [0] = X [j  ] / d [0] ;
	    y [1] = X [j-1] / d [1] ;
#else
	    y [0] = X [j  ] ;
	    y [1] = X [j-1] ;
#endif
	    for (p++, q += 2 ; p < pend ; p++, q++)
	    {
		Int i = Li [p] ;
		y [0] -= Lx [p] * X [i] ;
		y [1] -= Lx [q] * X [i] ;
	    }
#ifdef LL
	    y [0] /= d [0] ;
	    y [1] = (y [1] - t * y [0]) / d [1] ;
#else
	    y [1] -= t * y [0] ;
#endif
	    X [j  ] = y [0] ;
	    X [j-1] = y [1] ;
	    j -= 2 ;	    /* 前进到L的下一列 */

	}
	else
	{

	    /* -------------------------------------------------------------- */
	    /* 用L的三列求解超节点 */
	    /* -------------------------------------------------------------- */

	    double y [3], t [3] ;
	    Int q = Lp [j-1] ;
	    Int r = Lp [j-2] ;
#ifdef DIAG
	    double d [3] ;
	    d [0] = Lx [p] ;
	    d [1] = Lx [q] ;
	    d [2] = Lx [r] ;
#endif
	    t [0] = Lx [q+1] ;
	    t [1] = Lx [r+1] ;
	    t [2] = Lx [r+2] ;
#ifdef LD
	    y [0] = X [j]   / d [0] ;
	    y [1] = X [j-1] / d [1] ;
	    y [2] = X [j-2] / d [2] ;
#else
	    y [0] = X [j] ;
	    y [1] = X [j-1] ;
	    y [2] = X [j-2] ;
#endif
	    for (p++, q += 2, r += 3 ; p < pend ; p++, q++, r++)
	    {
		Int i = Li [p] ;
		y [0] -= Lx [p] * X [i] ;
		y [1] -= Lx [q] * X [i] ;
		y [2] -= Lx [r] * X [i] ;
	    }
#ifdef LL
	    y [0] /= d [0] ;
	    y [1] = (y [1] - t [0] * y [0]) / d [1] ;
	    y [2] = (y [2] - t [2] * y [0] - t [1] * y [1]) / d [2] ;
#else
	    y [1] -= t [0] * y [0] ;
	    y [2] -= t [2] * y [0] + t [1] * y [1] ;
#endif
	    X [j-2] = y [2] ;
	    X [j-1] = y [1] ;
	    X [j  ] = y [0] ;
	    j -= 3 ;	    /* 前进到L的下一列 */
	}
    }
}


/* ========================================================================== */
/* === LSOLVE (2) =========================================================== */
/* ========================================================================== */

/* 求解L'x=b,b有两列 */

static void LSOLVE (PREFIX,2)
(
    sparse_factor *L,
    double X [ ][2]		    /* n*2按行排列 */
)
{
    double *Lx = L->x ;
    Int *Li = L->i ;
    Int *Lp = L->p ;
    Int *Lnz = L->nz ;
    Int j, n = L->n ;

    for (j = n-1 ; j >= 0 ; )
    {
	/* 列j的开头、结尾和长度 */
	Int p = Lp [j] ;
	Int lnz = Lnz [j] ;
	Int pend = p + lnz ;

	/* 找到超节点链(j, j-1, j-2) */
	if (j < 4 || lnz != Lnz [j-1] - 1 || Li [Lp [j-1]+1] != j)
	{

	    /* -------------------------------------------------------------- */
	    /* 用L的一列求解 */
	    /* -------------------------------------------------------------- */

	    double y [2] ;
#ifdef DIAG
	    double d = Lx [p] ;
#endif
#ifdef LD
	    y [0] = X [j][0] / d ;
	    y [1] = X [j][1] / d ;
#else
	    y [0] = X [j][0] ;
	    y [1] = X [j][1] ;
#endif
	    for (p++ ; p < pend ; p++)
	    {
		Int i = Li [p] ;
		y [0] -= Lx [p] * X [i][0] ;
		y [1] -= Lx [p] * X [i][1] ;
	    }
#ifdef LL
	    X [j][0] = y [0] / d ;
	    X [j][1] = y [1] / d ;
#else
	    X [j][0] = y [0] ;
	    X [j][1] = y [1] ;
#endif
	    j-- ;	/* 前进到L的下一列 */

	}
	else if (lnz != Lnz [j-2]-2 || Li [Lp [j-2]+2] != j)
	{

	    /* -------------------------------------------------------------- */
	    /* 用L的两列求解超节点 */
	    /* -------------------------------------------------------------- */

	    double y [2][2], t ;
	    Int q = Lp [j-1] ;
#ifdef DIAG
	    double d [2] ;
	    d [0] = Lx [p] ;
	    d [1] = Lx [q] ;
#endif
	    t = Lx [q+1] ;
#ifdef LD
	    y [0][0] = X [j  ][0] / d [0] ;
	    y [0][1] = X [j  ][1] / d [0] ;
	    y [1][0] = X [j-1][0] / d [1] ;
	    y [1][1] = X [j-1][1] / d [1] ;
#else
	    y [0][0] = X [j  ][0] ;
	    y [0][1] = X [j  ][1] ;
	    y [1][0] = X [j-1][0] ;
	    y [1][1] = X [j-1][1] ;
#endif
	    for (p++, q += 2 ; p < pend ; p++, q++)
	    {
		Int i = Li [p] ;
		y [0][0] -= Lx [p] * X [i][0] ;
		y [0][1] -= Lx [p] * X [i][1] ;
		y [1][0] -= Lx [q] * X [i][0] ;
		y [1][1] -= Lx [q] * X [i][1] ;
	    }
#ifdef LL
	    y [0][0] /= d [0] ;
	    y [0][1] /= d [0] ;
	    y [1][0] = (y [1][0] - t * y [0][0]) / d [1] ;
	    y [1][1] = (y [1][1] - t * y [0][1]) / d [1] ;
#else
	    y [1][0] -= t * y [0][0] ;
	    y [1][1] -= t * y [0][1] ;
#endif
	    X [j  ][0] = y [0][0] ;
	    X [j  ][1] = y [0][1] ;
	    X [j-1][0] = y [1][0] ;
	    X [j-1][1] = y [1][1] ;
	    j -= 2 ;	    /* 前进到L的下一列 */

	}
	else
	{

	    /* -------------------------------------------------------------- */
	    /* 用L的三列求解超节点 */
	    /* -------------------------------------------------------------- */

	    double y [3][2], t [3] ;
	    Int q = Lp [j-1] ;
	    Int r = Lp [j-2] ;
#ifdef DIAG
	    double d [3] ; 
	    d [0] = Lx [p] ;
	    d [1] = Lx [q] ;
	    d [2] = Lx [r] ;
#endif
	    t [0] = Lx [q+1] ;
	    t [1] = Lx [r+1] ;
	    t [2] = Lx [r+2] ;
#ifdef LD
	    y [0][0] = X [j  ][0] / d [0] ;
	    y [0][1] = X [j  ][1] / d [0] ;
	    y [1][0] = X [j-1][0] / d [1] ;
	    y [1][1] = X [j-1][1] / d [1] ;
	    y [2][0] = X [j-2][0] / d [2] ;
	    y [2][1] = X [j-2][1] / d [2] ;
#else
	    y [0][0] = X [j  ][0] ;
	    y [0][1] = X [j  ][1] ;
	    y [1][0] = X [j-1][0] ;
	    y [1][1] = X [j-1][1] ;
	    y [2][0] = X [j-2][0] ;
	    y [2][1] = X [j-2][1] ;
#endif
	    for (p++, q += 2, r += 3 ; p < pend ; p++, q++, r++)
	    {
		Int i = Li [p] ;
		y [0][0] -= Lx [p] * X [i][0] ;
		y [0][1] -= Lx [p] * X [i][1] ;
		y [1][0] -= Lx [q] * X [i][0] ;
		y [1][1] -= Lx [q] * X [i][1] ;
		y [2][0] -= Lx [r] * X [i][0] ;
		y [2][1] -= Lx [r] * X [i][1] ;
	    }
#ifdef LL
	    y [0][0] /= d [0] ;
	    y [0][1] /= d [0] ;
	    y [1][0] = (y [1][0] - t [0] * y [0][0]) / d [1] ;
	    y [1][1] = (y [1][1] - t [0] * y [0][1]) / d [1] ;
	    y [2][0] = (y [2][0] - t [2] * y [0][0] - t [1] * y [1][0]) / d [2];
	    y [2][1] = (y [2][1] - t [2] * y [0][1] - t [1] * y [1][1]) / d [2];
#else
	    y [1][0] -= t [0] * y [0][0] ;
	    y [1][1] -= t [0] * y [0][1] ;
	    y [2][0] -= t [2] * y [0][0] + t [1] * y [1][0] ;
	    y [2][1] -= t [2] * y [0][1] + t [1] * y [1][1] ;
#endif
	    X [j  ][0] = y [0][0] ;
	    X [j  ][1] = y [0][1] ;
	    X [j-1][0] = y [1][0] ;
	    X [j-1][1] = y [1][1] ;
	    X [j-2][0] = y [2][0] ;
	    X [j-2][1] = y [2][1] ;
	    j -= 3 ;	    /* 前进到L的下一列 */
	}
    }
}


/* ========================================================================== */
/* === LSOLVE (3) =========================================================== */
/* ========================================================================== */

/* 求解L'x=b,b有三列 */

static void LSOLVE (PREFIX,3)
(
    sparse_factor *L,
    double X [ ][3]		    /* n*3按行排列 */
)
{
    double *Lx = L->x ;
    Int *Li = L->i ;
    Int *Lp = L->p ;
    Int *Lnz = L->nz ;
    Int j, n = L->n ;

    for (j = n-1 ; j >= 0 ; )
    {
	/* 获取列j的开头、结尾和长度 */
	Int p = Lp [j] ;
	Int lnz = Lnz [j] ;
	Int pend = p + lnz ;

	/* 找到超节点链 (j, j-1, j-2) */
	if (j < 4 || lnz != Lnz [j-1] - 1 || Li [Lp [j-1]+1] != j)
	{

	    /* -------------------------------------------------------------- */
	    /* 用L的一列求解 */
	    /* -------------------------------------------------------------- */

	    double y [3] ;
#ifdef DIAG
	    double d = Lx [p] ;
#endif
#ifdef LD
	    y [0] = X [j][0] / d ;
	    y [1] = X [j][1] / d ;
	    y [2] = X [j][2] / d ;
#else
	    y [0] = X [j][0] ;
	    y [1] = X [j][1] ;
	    y [2] = X [j][2] ;
#endif
	    for (p++ ; p < pend ; p++)
	    {
		Int i = Li [p] ;
		y [0] -= Lx [p] * X [i][0] ;
		y [1] -= Lx [p] * X [i][1] ;
		y [2] -= Lx [p] * X [i][2] ;
	    }
#ifdef LL
	    X [j][0] = y [0] / d ;
	    X [j][1] = y [1] / d ;
	    X [j][2] = y [2] / d ;
#else
	    X [j][0] = y [0] ;
	    X [j][1] = y [1] ;
	    X [j][2] = y [2] ;
#endif
	    j-- ;	/* 前进到L的下一列 */

	}
	else if (lnz != Lnz [j-2]-2 || Li [Lp [j-2]+2] != j)
	{

	    /* -------------------------------------------------------------- */
	    /* 用L的两列求解超节点 */
	    /* -------------------------------------------------------------- */

	    double y [2][3], t ;
	    Int q = Lp [j-1] ;
#ifdef DIAG
	    double d [2] ;
	    d [0] = Lx [p] ;
	    d [1] = Lx [q] ;
#endif
	    t = Lx [q+1] ;
#ifdef LD
	    y [0][0] = X [j  ][0] / d [0] ;
	    y [0][1] = X [j  ][1] / d [0] ;
	    y [0][2] = X [j  ][2] / d [0] ;
	    y [1][0] = X [j-1][0] / d [1] ;
	    y [1][1] = X [j-1][1] / d [1] ;
	    y [1][2] = X [j-1][2] / d [1] ;
#else
	    y [0][0] = X [j  ][0] ;
	    y [0][1] = X [j  ][1] ;
	    y [0][2] = X [j  ][2] ;
	    y [1][0] = X [j-1][0] ;
	    y [1][1] = X [j-1][1] ;
	    y [1][2] = X [j-1][2] ;
#endif
	    for (p++, q += 2 ; p < pend ; p++, q++)
	    {
		Int i = Li [p] ;
		y [0][0] -= Lx [p] * X [i][0] ;
		y [0][1] -= Lx [p] * X [i][1] ;
		y [0][2] -= Lx [p] * X [i][2] ;
		y [1][0] -= Lx [q] * X [i][0] ;
		y [1][1] -= Lx [q] * X [i][1] ;
		y [1][2] -= Lx [q] * X [i][2] ;
	    }
#ifdef LL
	    y [0][0] /= d [0] ;
	    y [0][1] /= d [0] ;
	    y [0][2] /= d [0] ;
	    y [1][0] = (y [1][0] - t * y [0][0]) / d [1] ;
	    y [1][1] = (y [1][1] - t * y [0][1]) / d [1] ;
	    y [1][2] = (y [1][2] - t * y [0][2]) / d [1] ;
#else
	    y [1][0] -= t * y [0][0] ;
	    y [1][1] -= t * y [0][1] ;
	    y [1][2] -= t * y [0][2] ;
#endif
	    X [j  ][0] = y [0][0] ;
	    X [j  ][1] = y [0][1] ;
	    X [j  ][2] = y [0][2] ;
	    X [j-1][0] = y [1][0] ;
	    X [j-1][1] = y [1][1] ;
	    X [j-1][2] = y [1][2] ;
	    j -= 2 ;	    /* 前进到L的下一列 */

	}
	else
	{

	    /* -------------------------------------------------------------- */
	    /* 用L的三列求解超节点 */
	    /* -------------------------------------------------------------- */

	    double y [3][3], t [3] ;
	    Int q = Lp [j-1] ;
	    Int r = Lp [j-2] ;
#ifdef DIAG
	    double d [3] ;
	    d [0] = Lx [p] ;
	    d [1] = Lx [q] ;
	    d [2] = Lx [r] ;
#endif
	    t [0] = Lx [q+1] ;
	    t [1] = Lx [r+1] ;
	    t [2] = Lx [r+2] ;
#ifdef LD
	    y [0][0] = X [j  ][0] / d [0] ;
	    y [0][1] = X [j  ][1] / d [0] ;
	    y [0][2] = X [j  ][2] / d [0] ;
	    y [1][0] = X [j-1][0] / d [1] ;
	    y [1][1] = X [j-1][1] / d [1] ;
	    y [1][2] = X [j-1][2] / d [1] ;
	    y [2][0] = X [j-2][0] / d [2] ;
	    y [2][1] = X [j-2][1] / d [2] ;
	    y [2][2] = X [j-2][2] / d [2] ;
#else
	    y [0][0] = X [j  ][0] ;
	    y [0][1] = X [j  ][1] ;
	    y [0][2] = X [j  ][2] ;
	    y [1][0] = X [j-1][0] ;
	    y [1][1] = X [j-1][1] ;
	    y [1][2] = X [j-1][2] ;
	    y [2][0] = X [j-2][0] ;
	    y [2][1] = X [j-2][1] ;
	    y [2][2] = X [j-2][2] ;
#endif
	    for (p++, q += 2, r += 3 ; p < pend ; p++, q++, r++)
	    {
		Int i = Li [p] ;
		y [0][0] -= Lx [p] * X [i][0] ;
		y [0][1] -= Lx [p] * X [i][1] ;
		y [0][2] -= Lx [p] * X [i][2] ;
		y [1][0] -= Lx [q] * X [i][0] ;
		y [1][1] -= Lx [q] * X [i][1] ;
		y [1][2] -= Lx [q] * X [i][2] ;
		y [2][0] -= Lx [r] * X [i][0] ;
		y [2][1] -= Lx [r] * X [i][1] ;
		y [2][2] -= Lx [r] * X [i][2] ;
	    }
#ifdef LL
	    y [0][0] /= d [0] ;
	    y [0][1] /= d [0] ;
	    y [0][2] /= d [0] ;
	    y [1][0] = (y [1][0] - t [0] * y [0][0]) / d [1] ;
	    y [1][1] = (y [1][1] - t [0] * y [0][1]) / d [1] ;
	    y [1][2] = (y [1][2] - t [0] * y [0][2]) / d [1] ;
	    y [2][0] = (y [2][0] - t [2] * y [0][0] - t [1] * y [1][0]) / d [2];
	    y [2][1] = (y [2][1] - t [2] * y [0][1] - t [1] * y [1][1]) / d [2];
	    y [2][2] = (y [2][2] - t [2] * y [0][2] - t [1] * y [1][2]) / d [2];
#else
	    y [1][0] -= t [0] * y [0][0] ;
	    y [1][1] -= t [0] * y [0][1] ;
	    y [1][2] -= t [0] * y [0][2] ;
	    y [2][0] -= t [2] * y [0][0] + t [1] * y [1][0] ;
	    y [2][1] -= t [2] * y [0][1] + t [1] * y [1][1] ;
	    y [2][2] -= t [2] * y [0][2] + t [1] * y [1][2] ;
#endif
	    X [j  ][0] = y [0][0] ;
	    X [j  ][1] = y [0][1] ;
	    X [j  ][2] = y [0][2] ;
	    X [j-1][0] = y [1][0] ;
	    X [j-1][1] = y [1][1] ;
	    X [j-1][2] = y [1][2] ;
	    X [j-2][0] = y [2][0] ;
	    X [j-2][1] = y [2][1] ;
	    X [j-2][2] = y [2][2] ;
	    j -= 3 ;	    /* 前进到L的下一列 */
	}
    }
}


/* ========================================================================== */
/* === LSOLVE (4) =========================================================== */
/* ========================================================================== */

/* 求解L'x=b, b有四列 */

static void LSOLVE (PREFIX,4)
(
    sparse_factor *L,
    double X [ ][4]		    /* n*4按行排列 */
)
{
    double *Lx = L->x ;
    Int *Li = L->i ;
    Int *Lp = L->p ;
    Int *Lnz = L->nz ;
    Int j, n = L->n ;

    for (j = n-1 ; j >= 0 ; )
    {
	/* 获取列j的开头、结尾和长度 */
	Int p = Lp [j] ;
	Int lnz = Lnz [j] ;
	Int pend = p + lnz ;

	/* 找到超节点链 (j, j-1, j-2) */
	if (j < 4 || lnz != Lnz [j-1] - 1 || Li [Lp [j-1]+1] != j)
	{

	    /* -------------------------------------------------------------- */
	    /* 用L的一列求解 */
	    /* -------------------------------------------------------------- */

	    double y [4] ;
#ifdef DIAG
	    double d = Lx [p] ;
#endif
#ifdef LD
	    y [0] = X [j][0] / d ;
	    y [1] = X [j][1] / d ;
	    y [2] = X [j][2] / d ;
	    y [3] = X [j][3] / d ;
#else
	    y [0] = X [j][0] ;
	    y [1] = X [j][1] ;
	    y [2] = X [j][2] ;
	    y [3] = X [j][3] ;
#endif
	    for (p++ ; p < pend ; p++)
	    {
		Int i = Li [p] ;
		y [0] -= Lx [p] * X [i][0] ;
		y [1] -= Lx [p] * X [i][1] ;
		y [2] -= Lx [p] * X [i][2] ;
		y [3] -= Lx [p] * X [i][3] ;
	    }
#ifdef LL
	    X [j][0] = y [0] / d ;
	    X [j][1] = y [1] / d ;
	    X [j][2] = y [2] / d ;
	    X [j][3] = y [3] / d ;
#else
	    X [j][0] = y [0] ;
	    X [j][1] = y [1] ;
	    X [j][2] = y [2] ;
	    X [j][3] = y [3] ;
#endif
	    j-- ;	/* 前进到L的下一列 */

	}
	else /* if (j == 1 || lnz != Lnz [j-2]-2 || Li [Lp [j-2]+2] != j) */
	{

	    /* -------------------------------------------------------------- */
	    /* 用L的两列求解超节点 */
	    /* -------------------------------------------------------------- */

	    double y [2][4], t ;
	    Int q = Lp [j-1] ;
#ifdef DIAG
	    double d [2] ;
	    d [0] = Lx [p] ;
	    d [1] = Lx [q] ;
#endif
	    t = Lx [q+1] ;
#ifdef LD
	    y [0][0] = X [j  ][0] / d [0] ;
	    y [0][1] = X [j  ][1] / d [0] ;
	    y [0][2] = X [j  ][2] / d [0] ;
	    y [0][3] = X [j  ][3] / d [0] ;
	    y [1][0] = X [j-1][0] / d [1] ;
	    y [1][1] = X [j-1][1] / d [1] ;
	    y [1][2] = X [j-1][2] / d [1] ;
	    y [1][3] = X [j-1][3] / d [1] ;
#else
	    y [0][0] = X [j  ][0] ;
	    y [0][1] = X [j  ][1] ;
	    y [0][2] = X [j  ][2] ;
	    y [0][3] = X [j  ][3] ;
	    y [1][0] = X [j-1][0] ;
	    y [1][1] = X [j-1][1] ;
	    y [1][2] = X [j-1][2] ;
	    y [1][3] = X [j-1][3] ;
#endif
	    for (p++, q += 2 ; p < pend ; p++, q++)
	    {
		Int i = Li [p] ;
		y [0][0] -= Lx [p] * X [i][0] ;
		y [0][1] -= Lx [p] * X [i][1] ;
		y [0][2] -= Lx [p] * X [i][2] ;
		y [0][3] -= Lx [p] * X [i][3] ;
		y [1][0] -= Lx [q] * X [i][0] ;
		y [1][1] -= Lx [q] * X [i][1] ;
		y [1][2] -= Lx [q] * X [i][2] ;
		y [1][3] -= Lx [q] * X [i][3] ;
	    }
#ifdef LL
	    y [0][0] /= d [0] ;
	    y [0][1] /= d [0] ;
	    y [0][2] /= d [0] ;
	    y [0][3] /= d [0] ;
	    y [1][0] = (y [1][0] - t * y [0][0]) / d [1] ;
	    y [1][1] = (y [1][1] - t * y [0][1]) / d [1] ;
	    y [1][2] = (y [1][2] - t * y [0][2]) / d [1] ;
	    y [1][3] = (y [1][3] - t * y [0][3]) / d [1] ;
#else
	    y [1][0] -= t * y [0][0] ;
	    y [1][1] -= t * y [0][1] ;
	    y [1][2] -= t * y [0][2] ;
	    y [1][3] -= t * y [0][3] ;
#endif
	    X [j  ][0] = y [0][0] ;
	    X [j  ][1] = y [0][1] ;
	    X [j  ][2] = y [0][2] ;
	    X [j  ][3] = y [0][3] ;
	    X [j-1][0] = y [1][0] ;
	    X [j-1][1] = y [1][1] ;
	    X [j-1][2] = y [1][2] ;
	    X [j-1][3] = y [1][3] ;
	    j -= 2 ;	    /* 前进到L的下一列 */
	}

	/* 注意: 有了4 right-hand-sides, 它就足以利用大小仅为1和2的动态超级节点。
	 * 不需要三列超级节点。 */
    }
}

#endif

/* ========================================================================== */
/* === LSOLVE (k) =========================================================== */
/* ========================================================================== */

static void LSOLVE (PREFIX,k)
(
    sparse_factor *L,
    dense_array *Y,		    /* nr*n 其中nr为1~4 */
    Int *Yseti, Int ysetlen
)
{

#ifdef DIAG
    double d [1] ;
#endif
    double yx [2] ;
#ifdef ZOMPLEX
    double yz [1] ;
    double *Lz = L->z ;
    double *Xz = Y->z ;
#endif
    double *Lx = L->x ;
    double *Xx = Y->x ;
    Int *Li = L->i ;
    Int *Lp = L->p ;
    Int *Lnz = L->nz ;
    Int n = L->n, jj, jjiters ;

    

#ifdef REAL

    if (Yseti == NULL)
    {

        /* ------------------------------------------------------------------ */
        /* 真实情况下，没有Yseti，只有1到4个RHS和动态超节点 */
        /* ------------------------------------------------------------------ */

        switch (Y->nrow)
        {
            case 1: LSOLVE (PREFIX,1) (L, Y->x) ; break ;
            case 2: LSOLVE (PREFIX,2) (L, Y->x) ; break ;
            case 3: LSOLVE (PREFIX,3) (L, Y->x) ; break ;
            case 4: LSOLVE (PREFIX,4) (L, Y->x) ; break ;
        }

    }
    else
#endif
    {

        /* ------------------------------------------------------------------ */
        /* 解决一个复杂的线性系统或解决Yseti */
        /* ------------------------------------------------------------------ */

        jjiters = Yseti ? ysetlen : n ;

        for (jj = jjiters-1 ; jj >= 0 ; jj--)
        {

            Int j = Yseti ? Yseti [jj] : jj ;

            /* 获取列j的开头、结尾和长度 */
            Int p = Lp [j] ;
            Int lnz = Lnz [j] ;
            Int pend = p + lnz ;

            /* y = X [j] ; */
            ASSIGN (yx,yz,0, Xx,Xz,j) ;

#ifdef DIAG
            /* d = Lx [p] ; */
            ASSIGN_REAL (d,0, Lx,p) ;
#endif
#ifdef LD
            /* y /= d ; */
            DIV_REAL (yx,yz,0, yx,yz,0, d,0) ;
#endif

            for (p++ ; p < pend ; p++)
            {
                /* y -= conj (Lx [p]) * X [Li [p]] ; */
                Int i = Li [p] ;
                MULTSUBCONJ (yx,yz,0, Lx,Lz,p, Xx,Xz,i) ;
            }

#ifdef LL
            /* X [j] = y / d ; */
            DIV_REAL (Xx,Xz,j, yx,yz,0, d,0) ;
#else
            /* X [j] = y ; */
            ASSIGN (Xx,Xz,j, yx,yz,0) ;
#endif

        }
    }
}

/* 准备在SparseChol_solve.c中包含这个文件 */
#undef LL
#undef LD